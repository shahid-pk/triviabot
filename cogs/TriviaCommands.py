import asynciofrom discord.ext import commandsfrom cogs.StaffCommands import permfrom cogs.utils.Permissions import permcheckfrom cogs.utils.TriviaBackend import getserver, getuser, qmsgfrom fuzzywuzzy import processclass TriviaCommands:    # timeout before deleting messages in seconds    timeout = 2    def __init__(self, bot):        self.bot: commands.Bot = bot        # get the same serverdict as loaded by the StaffCommands cog.        self.serverdict = self.bot.cogs['StaffCommands'].serverdict    @commands.command(pass_context = True)    async def a(self, ctx, *, answer: str = None):        """        Answer the question.        """        server = getserver(self.serverdict, ctx)        user = getuser(self.serverdict, ctx)        # return if no question was asked        if not server.q:            bm = await self.bot.say(f':question: | {ctx.message.author.mention} No question asked.')            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)            return        # return if no answer was provided, or it wasn't one of the options        if not answer:            bm = await self.bot.say(f':grey_question: | {ctx.message.author.mention} No answer provided. '                                    f'Answer with `,a %answer%`')            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)            return        print('{} in {} is trying to answer "{}" with answer "{}"'.format(ctx.message.author, ctx.message.server,                                                                          server.q['question'], answer))        # return if the user already answered        if ctx.message.author.id in server.already_answered:            print("{} already answered. ignoring...".format(ctx.message.author))            bm = await self.bot.say(f":bangbang: | {ctx.message.author.mention} You already used up your answer.")            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)            return        # fuzzy matching        nofuz = False        # makes sure every option has more characters than the specified minimum for the server. defaults to 10.        # this is to ensure meaningful fuzzy matching.        for i in server.q['options']:            if len(i) <= server.fuzzymin:                nofuz = True        # if fuzzy matching:        if not nofuz:            # get the best match out of the options            fuz = process.extractOne(answer.lower(), [x.lower() for x in server.q['options']])            print(f'{ctx.message.author} got {fuz[1]}% fuzzy match')            # if the match percentage is lower than the server specific threshold, deal with it as a non-answer.            if fuz[1] <= server.fuzzythreshold:                bm = await self.bot.say(f':exclamation: | {ctx.message.author.mention} Only one of the four options '                                        f'are accepted. No answer index numbers.')                await asyncio.sleep(self.timeout)                await self.bot.delete_message(bm)                await self.bot.delete_message(ctx.message)                return            # if the match percentage is meaningful, assign check to whether it's the correct answer or not.            # check is a boolean btw            check = fuz[0] == server.q['answer'].lower()        # here, we aren't doing any fuzzy matching, so this check gets assigned into the normal pre-fuzzy check.        else:            if answer.lower() not in [str(server.q['options'][0]).lower(), str(server.q['options'][1]).lower(),                                      str(server.q['options'][2]).lower(), str(server.q['options'][3]).lower()]:                bm = await self.bot.say(f':exclamation: | {ctx.message.author.mention} Only one of the four options '                                        f'are accepted. No answer index numbers.')                await asyncio.sleep(self.timeout)                await self.bot.delete_message(bm)                await self.bot.delete_message(ctx.message)                return            check = answer.lower() == server.q['answer'].lower()        # add the user to the list of already answered        server.already_answered.append(ctx.message.author.id)        # if the answer is correct, and this is the first user to answer correctly        if server.accept and check:            server.accept = False            print("{} answered correctly.".format(str(ctx.message.author)))            print("-" * 12)            # add 10 points to the user and write it immediately            user.add_correct()            await self.bot.say(f":white_check_mark: | {ctx.message.author.mention} Congratulations! You got it! "                               f"10 points!")            # throw the question off this server's stack            done = server.nextquestion()            # if the server's stack is out of questions            if done:                print("Out of questions. displaying scoreboard...", end = ' ')                embed = server.getscoreboard()                await self.bot.say("That's all I have, folks!", embed = embed)                server.resetquestions()                print("Scoreboard displayed.")                print('-' * 12)            server.accept = True        # if the answer is correct, but this isn't the first user to answer correctly - the question still isn't thrown.        # believe me, it happened.        elif check:            print("{} answered correctly, but was too slow!".format(ctx.message.author))            bm = await self.bot.say(":clock2: | Too slow, {}!".format(ctx.message.author.mention))            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)        # if neither of the above are it, the answer must be wrong.        else:            user.add_incorrect()            print("{} answered incorrectly.".format(str(ctx.message.author)))            bm = await self.bot.say(":x: | Wrong answer, {}.".format(ctx.message.author.mention))            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)    @commands.command(pass_context = True, aliases = ['leaderboard', 'board'])    async def scoreboard(self, ctx):        """        Show everyone's score.        """        server = getserver(self.serverdict, ctx)        print("{} in {} is trying to get the scoreboard...".format(ctx.message.author, ctx.message.server), end = ' ')        # does exactly what it says on the tin - gets the scoreboard, an embed.        embed = server.getscoreboard()        await self.bot.say(embed = embed)        print("Scoreboard displayed.")    @commands.command(pass_context = True, aliases = ['points'])    async def score(self, ctx):        """        Get a user's points.        You may check someone else's score by mentioning them, such as: ,score *mention*        """        if len(ctx.message.mentions) > 0:            user = getuser(self.serverdict, ctx, mentions = ctx.message.mentions[0])        else:            user = getuser(self.serverdict, ctx)        await self.bot.say("{} has {} points.".format(user.mention, user.points))    @commands.command(pass_context = True, aliases = ['question'])    async def trivia(self, ctx):        """        Get a single trivia question.        """        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say("You can't get a question when TriviaNight mode is on!")            return        # set the server.q property to the question at the top of the question list, and send it.        server.dispense(ctx)        await self.bot.say(            server.q['question'] + "\n" + qmsg.format(server.q['options'][0], server.q['options'][1],                                                      server.q['options'][2], server.q['options'][3]))        print('"{}" dispensed.'.format(server.q['question']))def setup(bot):    x = TriviaCommands(bot)    bot.add_cog(x)