import asynciofrom discord.ext import commandsfrom cogs.StaffCommands import permfrom cogs.utils.Permissions import permcheckfrom cogs.utils.TriviaBackend import getserver, getuser, qmsgfrom fuzzywuzzy import processclass TriviaCommands:    # timeout before deleting messages in seconds    timeout = 2    # message to send when a command us called by a normal user in trivia night mode    tnmsg = "You can't do that when TriviaNight mode is on!"    def __init__(self, bot):        self.bot: commands.Bot = bot        # get the same serverdict as loaded by the StaffCommands cog.        self.serverdict = self.bot.cogs['StaffCommands'].serverdict    @commands.command(pass_context = True)    async def a(self, ctx, *, answer: str = None):        """        Answer the question.        """        server = getserver(self.serverdict, ctx)        user = getuser(self.serverdict, ctx)        # return if no question was asked        if not server.q:            bm = await self.bot.say(f':question: | {ctx.message.author.mention} No question asked.')            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)            return        # return if no answer was provided, or it wasn't one of the options        if not answer:            bm = await self.bot.say(f':grey_question: | {ctx.message.author.mention} No answer provided. '                                    f'Answer with `,a %answer%`')            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)            return        print('{} in {} is trying to answer "{}" with answer "{}"'.format(ctx.message.author, ctx.message.server,                                                                          server.q['question'], answer))        # return if the user already answered        if ctx.message.author.id in server.already_answered:            print("{} already answered. ignoring...".format(ctx.message.author))            bm = await self.bot.say(f":bangbang: | {ctx.message.author.mention} You already used up your answer.")            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)            return        # fuzzy matching        nofuz = False        # makes sure every option has more characters than the specified minimum for the server. defaults to 10.        # this is to ensure meaningful fuzzy matching.        for i in server.q['options']:            if len(i) <= server.fuzzymin:                nofuz = True        # if fuzzy matching:        if not nofuz:            # get the best match out of the options            fuz = process.extractOne(answer.lower(), [x.lower() for x in server.q['options']])            print(f'{ctx.message.author} got {fuz[1]}% fuzzy match')            # if the match percentage is lower than the server specific threshold, deal with it as a non-answer.            if fuz[1] <= server.fuzzythreshold:                bm = await self.bot.say(f':exclamation: | {ctx.message.author.mention} Only one of the four options '                                        f'are accepted. No answer index numbers.')                await asyncio.sleep(self.timeout)                await self.bot.delete_message(bm)                await self.bot.delete_message(ctx.message)                return            # if the match percentage is meaningful, assign check to whether it's the correct answer or not.            # check is a boolean btw            check = fuz[0] == server.q['answer'].lower()        # here, we aren't doing any fuzzy matching, so this check gets assigned into the normal pre-fuzzy check.        else:            if answer.lower() not in [str(server.q['options'][0]).lower(), str(server.q['options'][1]).lower(),                                      str(server.q['options'][2]).lower(), str(server.q['options'][3]).lower()]:                bm = await self.bot.say(f':exclamation: | {ctx.message.author.mention} Only one of the four options '                                        f'are accepted. No answer index numbers.')                await asyncio.sleep(self.timeout)                await self.bot.delete_message(bm)                await self.bot.delete_message(ctx.message)                return            check = answer.lower() == server.q['answer'].lower()        # add the user to the list of already answered        server.already_answered.append(ctx.message.author.id)        # if the answer is correct, and this is the first user to answer correctly        if server.accept and check:            server.accept = False            print("{} answered correctly.".format(str(ctx.message.author)))            print("-" * 12)            # add 10 points to the user and write it immediately            user.add_correct()            await self.bot.say(f":white_check_mark: | {ctx.message.author.mention} Congratulations! You got it! "                               f"10 points!")            # throw the question off this server's stack            done = server.nextquestion()            # if the server's stack is out of questions            if done:                print("Out of questions. displaying scoreboard...", end = ' ')                embed = server.getscoreboard()                await self.bot.say("That's all I have, folks!", embed = embed)                server.resetquestions()                print("Scoreboard displayed.")                print('-' * 12)            server.accept = True        # if the answer is correct, but this isn't the first user to answer correctly - the question still isn't thrown.        # believe me, it happened.        elif check:            print("{} answered correctly, but was too slow!".format(ctx.message.author))            bm = await self.bot.say(":clock2: | Too slow, {}!".format(ctx.message.author.mention))            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)        # if neither of the above are it, the answer must be wrong.        else:            user.add_incorrect()            print("{} answered incorrectly.".format(str(ctx.message.author)))            bm = await self.bot.say(":x: | Wrong answer, {}.".format(ctx.message.author.mention))            await asyncio.sleep(self.timeout)            await self.bot.delete_message(bm)            await self.bot.delete_message(ctx.message)    @commands.command(pass_context = True, aliases = ['leaderboard', 'board'])    async def scoreboard(self, ctx):        """        Show everyone's score.        """        server = getserver(self.serverdict, ctx)        print("{} in {} is trying to get the scoreboard...".format(ctx.message.author, ctx.message.server), end = ' ')        # does exactly what it says on the tin - gets the scoreboard, an embed.        embed = server.getscoreboard()        await self.bot.say(embed = embed)        print("Scoreboard displayed.")    @commands.command(pass_context = True, aliases = ['points'])    async def score(self, ctx):        """        Get a user's points.        You may check someone else's score by mentioning them, such as: ,score *mention*        """        if len(ctx.message.mentions) > 0:            user = getuser(self.serverdict, ctx, mentions = ctx.message.mentions[0])        else:            user = getuser(self.serverdict, ctx)        await self.bot.say("{} has {} points.".format(user.mention, user.points))    @commands.command(pass_context = True, aliases = ['question'])    async def trivia(self, ctx):        """        Get a single trivia question.        """        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        # set the server.q property to the question at the top of the question list, and send it.        server.dispense(ctx)        await self.bot.say(            server.q['question'] + "\n" + qmsg.format(server.q['options'][0], server.q['options'][1],                                                      server.q['options'][2], server.q['options'][3]))        print('"{}" dispensed.'.format(server.q['question']))    @commands.command(pass_context = True, aliases = ['start'])    async def starttrivia(self, ctx):        """        Calls ,trivia, until the bot runs out of questions.        """        # get the server        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        # if it isn't already continuously dispensing questions, continue. else, don't do anything        # this is because, if this command was called multiple times, the bot would have multiple async instances inside        # the while loop.        if not server.do_trivia:            # as explained above, allows for only one instance.            server.do_trivia = True            # if a question was asked prior to starting the command, retell the question            if server.q:                retellq = True            else:                retellq = False            # this loop stops when `do_trivia` is set to False by another command, `stoptrivia`.            while server.do_trivia:                # if questionlist is empty, the look should stop.                if not server.questionlist:                    server.do_trivia = False                    break                # if a question was asked but was answered, thereby clearing the property `q`, post a question.                if not server.q:                    # basically sets `q` to a new question                    server.dispense(ctx)                    # nicely format the question                    await self.bot.say(                        server.q['question'] + "\n" + qmsg.format(server.q['options'][0],                                                                  server.q['options'][1],                                                                  server.q['options'][2],                                                                  server.q['options'][3]))                    print('"{}" dispensed.'.format(server.q['question']))                # if the previous retell check passed, go into this block, set retell to False as to not post the                # question every 2 seconds(it has happened, btw), and send the question. nothing peculiar about it.                elif retellq:                    retellq = False                    await self.bot.say(                        server.q['question'] + "\n" + qmsg.format(server.q['options'][0],                                                                  server.q['options'][1],                                                                  server.q['options'][2],                                                                  server.q['options'][3]))                    print('Retold question "{}" in {}.'.format(server.q['question'], ctx.message.server))                # async sleep for 2 seconds.                await asyncio.sleep(2)    @commands.command(pass_context = True, aliases = ['stop'])    async def stoptrivia(self, ctx):        """        Stop the command ,starttrivia.        """        # see above command to know how `do_trivia` fits in        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        server.do_trivia = False        await self.bot.say("Trivia stopped.")    @commands.command(pass_context = True)    async def resetscore(self, ctx):        """        Resets a user's score.        You may reset someone else's score by mentioning them.        """        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        # if more than one mention was included in the message, the first mention is our target. otherwise, the author.        if len(ctx.message.mentions) > 0:            user = getuser(self.serverdict, ctx, mentions = ctx.message.mentions[0])        else:            user = getuser(self.serverdict, ctx)        # sets the user's points to 0, and writes it to the Users.json file for the server.        user.points = 0        user.write()        # removes the user from server.userdict        server.userdict.pop(user.id)        await self.bot.say("{}'s score has been reset.".format(user.mention))    @commands.command(pass_context = True)    async def count(self, ctx):        """        Get number of questions.        """        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        # simple math. totalquestions is the total, answered is the difference between the total and the remaining,        # and the remaining is questionlist.        await self.bot.say("I have a total of {} questions, {} of which has been answered, and {} remain unanswered."                           .format(server.totalquestions, server.totalquestions - len(server.questionlist),                                   len(server.questionlist)))    @commands.command(pass_context = True)    async def resetallscores(self, ctx):        """        Resets all the user's scores.        You shouldn't need to do this in most cases, but it's there. Just in case.        """        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        # does exactly what it says on the tin - resets the scores.        server.resetscores()        await self.bot.say("All scores reset.")    @commands.command(pass_context = True)    async def reset(self, ctx):        """        Resets/starts over the questions.        Basically resets the questions stack.        """        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        print("Resetting questions in {}...".format(ctx.message.server), end = ' ')        # does exactly what it says on the tin - resets the questions.        server.resetquestions()        print("Questions reset.")        print("-" * 12)        await self.bot.say("Questions reset.")    @commands.command(pass_context = True)    async def bypass(self, ctx):        """        Bypass a question.        This most likely will never have to be used.        """        server = getserver(self.serverdict, ctx)        if server.tn and not permcheck(ctx, check = perm):            await self.bot.say(self.tnmsg)            return        # if there is a question to bypass        if server.q:            q = server.q            # bypasses the question and returns whether said question was the last one or not.            b = server.nextquestion()            print("{} in {} is trying to bypass a question...".format(ctx.message.author, ctx.message.server))            await self.bot.say('Question "{}" thrown off stack.'.format(q['question']))            print('Bypassed "{}".'.format(q['question']))            # if it is, display the scoreboard and reset the questions.            if b:                print("Out of questions. displaying scoreboard...", end = ' ')                await self.bot.say("That's all I have, folks!")                embed = server.getscoreboard()                await self.bot.say(embed = embed)                server.resetquestions()                print("Scoreboard displayed")        else:            print("which hasn't been asked! {0} pls".format(ctx.message.author))            await self.bot.say("There is no question to bypass.")def setup(bot):    x = TriviaCommands(bot)    bot.add_cog(x)